module System
  LOGO = "app_logo"
  DESCRIPTION = "An RGSS-based engine"
  def self.user_language
    @user_language
  end

  def self.platform
    NAME
  end

  def self.linux?
    FAMILY_NAME[/linux/i] != nil
  end

  def self.windows?
    FAMILY_NAME[/windows/i] != nil
  end
end

module Input
  KEYBOARD_GENERIC = "kb_generic"
  class Gamepad
    attr_reader :vendor_fn, :int_name
    def initialize(name, vendor_id, kind, level, state1, state2)
      @name = name
      @vendor = @@vendors[vendor_id]
      @vendor_id = vendor_id
      @type = @@types[kind]
      @type_number = kind
      @power = @@levels[level]
      @power_level = level
      @rumble = state1
      @last_rumble = nil
      @active = state2
      set_int_vendor_name
      set_int_gamepad_name
    end

    def set_int_vendor_name
      case @vendor
      when /Sony/i
        return @vendor_fn = "sony"
      when /Logitech/i
        return @vendor_fn = "logi"
      when /Microsoft/i
        return @vendor_fn = "ms"
      when /Nintendo/i
        return @vendor_fn = "nint"
      when /Asustek/i
        return @vendor_fn = "asus"
      when /Logic3/i
        return @vendor_fn = "log3"
      when /Razer/i
        return @vendor_fn = "razer"
      when /ZD/i
        return @vendor_fn = "zd"
      when /8BitDo/i
        return @vendor_fn = "8bit"
      when /SCUF/i
        return @vendor_fn = "scuf"
      else
        @vendor_fn = "kb"
      end
    end

    def set_int_gamepad_name
      case @name
      when /(PS\d)/i
        return @int_name = $1.downcase
      when /Dual Action/i
        return @int_name = "duact"
      when /Wolverine/i
        return @int_name = "wolve"
      when /Raiju/i
        return @int_name = "raiju"
      when /ZD\-?V/i
        return @int_name = "zdv"
      else
        @int_name = "generic"
      end
    end

    def internal_name
      @vendor_fn + "_" + @int_name
    end
  end

  class KeyBinding
    TYPES = ["Invalid", "Key", "Button", "Axis", "Hat"]
    def initialize
      clear_invalid
    end

    def clear_invalid
      self.type = 0
      @value = 0
      @scancode = 0
      @dir = 0
      @symbol = nil
      @name = ""
    end

    def type=(tp)
      @type_name = TYPES[tp]
      @type = tp
    end

    def name=(text)
      @name = text.chomp
      refresh_type
      @name
    end

    def refresh_type
      if @name.empty?
        clear_invalid
        return
      elsif @name[/F(\d+)/i]
        if [1, 12].include?($1.to_i)
          clear_invalid
          return
        end
        self.type = 1
        @symbol = @name.to_sym
        @value = BUTTON_CODES[@symbol]
        @scancode = BUTTON_SCANCODES[@value]
        return
      elsif @name[/(?:key|num)pad (\d+)/i]
        get_value_by_name
        return
      elsif @name[/js (\d+)/i]
        self.type = 2
        @symbol = nil
        @value = $1.to_i
        @scancode = 0
        @dir = 0
        return
      elsif @name[/axis (\d+)(\+|\-)/i]
        self.type = 3
        @symbol = nil
        @value = $1.to_i
        @scancode = 0
        @dir = $2 == "+" ? 1 : 0
        return
      elsif @name[/hat (\d+).(\w)/i]
        self.type = 4
        @symbol = nil
        @value = $1.to_i
        @scancode = 0
        @dir = get_hat_pos($2)
        return
      elsif @name[/(?:\/|Divide)/i]
        @name = "NumPad Divide"
        get_value_by_name
        return
      elsif @name[/(?:\*|Multiply)/i]
        @name = "NumPad Multiply"
        get_value_by_name
        return
      elsif @name[/(?:\-|Minus)/i]
        @name = "NumPad Minus"
        get_value_by_name
        return
      elsif @name[/(?:\*|Plus)/i]
        @name = "NumPad Plus"
        get_value_by_name
        return
      elsif @name[/(\A[\.]|Dot)/i]
        @name = "NumPad Dot"
        get_value_by_name
        return
      elsif @name[/\w+/i]
        self.type = 1
        s = @name.dup
        if s.size == 1 and s[/[a-z]/i]
          s = "Key" + s.upcase
        end
        @symbol = s.to_sym
        @value = BUTTON_CODES[@symbol]
        @scancode = BUTTON_SCANCODES[@value]
        @dir = 0
        return
      elsif @name[/\d/i]
        self.type = 1
        s = "N" + @name
        @symbol = s.to_sym
        @value = BUTTON_CODES[@symbol]
        @scancode = BUTTON_SCANCODES[@value]
        @dir = 0
        return
      else
        clear_invalid
      end
    end

    def get_value_by_name
      self.type = 1
      @name = @name.sub(/(?:key|num)p/i, "NumP")
      s = @name.sub(/ /, "")
      @symbol = s.to_sym
      @value = BUTTON_CODES[@symbol]
      @scancode = BUTTON_SCANCODES[@value]
      @dir = 0
    end

    def get_hat_pos(s)
      s =~ /u/i ? 1 : s =~ /r/i ? 2 : s =~ /d/i ? 4 : s =~ /l/i ? 8 : 0
    end

    def value=(n)
      @value = n
      self.type = Input.trigger_type
      case @type
      when 0
        clear_invalid
      when 1
        @name = KEY2NAME[@value]
        @symbol = BUTTON_CODES.key(@value)
        @scancode = BUTTON_SCANCODES[@value]
        @dir = 0
      when 2
        @name = "JS #{@value}"
        @symbol = nil
        @scancode = @dir = 0
      when 3
        @symbol = nil
        @scancode = 0
        @dir = Input.trigger_gp_dir
        sym = @dir == 0 ? "-" : "+"
        @name = @type_name + " #{@value}" + sym
      when 4
        @symbol = nil
        @scancode = 0
        @dir = Input.trigger_gp_dir
        str = get_hat_dir(@dir)
        @name = @type_name + " #{@dir}:" + str
      end
      Input.trigger_gp_clear
    end

    def get_hat_dir(s)
      s == 1 ? "U" : s == 2 ? "R" : s == 4 ? "D" : s == 8 ? "L" : ""
    end

    def state
      @type > 0 ? 1 : 0
    end
    attr_reader :name, :type, :type_name, :symbol, :value, :scancode, :dir
    attr_accessor :index
    private :refresh_type
  end

  class KeyBindingGroup
    def initialize
      @name = "?"
      @target = 0
      @data = Array.new(4) { KeyBinding.new }
    end

    def data
      @data[0..3]
    end

    def [](n)
      @data[n]
    end

    def []=(n, bind)
      return if n > 3
      @data[n] = bind
    end

    def active_bindings
      @data.inject(0) {|t, b| t + b.state }
    end
    attr_accessor :name, :target
  end

  class KeyBindings
    DEFAULT = %w{Up Down Q R Left Right W T Shift Escape Return F G H}
    def initialize
      @name = ""
      @code = ""
      @version = 0
      @size = 14
      @list = Array.new(@size) { KeyBindingGroup.new }
      @size.times {|n| @list[n].data[0].name = DEFAULT[n] }
    end

    def list
      @list[0..14]
    end

    def update_active
      @size = @list.inject(0) {|t, g| t + g.active_bindings }
    end
    attr_accessor :name, :version, :code
    attr_reader :size
  end

  extend self
  attr_reader :bindings, :all_bindings
  def self.load_init_bindings
    @all_bindings = {}
    ext = Game.data_ext
    files = Dir[Game.glob_kb].sort
    if files.any?
      puts "Loading Bindings..."
      load_all_bindings(files)
    end
    codes = @all_bindings.map {|k,v| v.code }
    files = Dir[Game.glob_init_kb].sort
    files.each do |file|
      code = File.basename(file, "." + ext)
      next if codes.include?(code)
      fn = "#{code}.#{ext}"
      puts "Moving #{fn} to User's Game Files Directory..."
      FileUtils.mv(file, Game.bindings_path(code))
      load_bindings(code)
      codes << code
    end
    inis = Dir["Input/*.ini"].sort
    if inis.any?
      inis.each_with_index do |fn, n|
        code = File.basename(fn, ".ini")
        next if codes.include?(code)
        parse_bindings(fn, code)
        puts "Saving New #{code} Binding..."
        save_bindings(code)
      end
    end
    if gamepad?
      @gamepad_updates << :add
      setup_gamepad
    else
      @gamepad_updates << :remove
      reset_gamepad
    end
  end

  def self.play_mode!
    self.text_input = 0
  end

  def self.text_mode!
    self.text_input = 1
  end

  def self.keymap_mode!
    self.text_input = 2
  end

  def self.mode
    case @text_input
    when 0
      "Play Mode"
    when 1
      "Text Input Mode"
    else
      "Key Mapping Mode"
    end
  end

  def self.save_key_bindings
    reset_sdl_bindings
    save_new_bindings
  end

  def self.update
    update_internal
    update_gamepad_state
    update_settings_state
  rescue => e
    puts e.full_message
  end

  private
  def self.update_gamepad_state
    state = gamepad_change?
    return if state == 0
    @gamepad_updates.pop
    if state == 2
      @gamepad_updates << :add
      setup_gamepad
    else
      if gamepad?
        @gamepad_updates << :add
        gamepad_open!
        setup_gamepad
      else
        @gamepad_updates << :remove
        reset_gamepad
      end
    end
  end

  def self.update_settings_state
    return unless gamepad_bindings_change?
    reset_ruby_bindings
    save_new_bindings
  end

  def self.save_new_bindings
    save_bindings(@gamepad.internal_name)
  end

  def self.setup_gamepad
    list = gamepad_basic_values
    list << true
    @gamepad = Gamepad.new(*list)
    reset_bindings
  end

  def self.reset_gamepad
    name = Gamepad::DEFAULT_NAME
    @gamepad = Gamepad.new(name, 0, 0, -1, false, false)
    reset_bindings
  end

  def self.reset_bindings
    code = @gamepad.internal_name.to_sym
    @bindings = @all_bindings[code] || KeyBindings.new
    gamepad_clear_change
    reset_sdl_bindings
  end

  def self.process_target_button(line)
    line.sub!(/(\w+)\s?=\s?/i, "")
    $1
  end

  def self.parse_bindings(fn, code)
    lines = File.readlines(fn)
    heading = lines.shift
    unless heading[/header/i]
      parsing_kb_error(code, "missing [Header]")
      return
    end
    name = lines.shift.chomp
    bind = KeyBindings.new
    bind.name = name.sub(/name\s?(=)\s?/i, "")
    bind.code = code
    unless $1
      parsing_kb_error(code, "missing = operator in line #{2}")
      return
    end
    bind.version = Game::RGSS_VERSION
    heading = lines.shift
    unless heading[/bindings/i]
      parsing_kb_error(code, "missing [Bindings]")
      return
    end
    slot_max = 4
    14.times do |n|
      line = lines.shift
      group = bind.list[n]
      group.target = n
      group.name = process_target_button(line)
      if group.name.empty?
        parsing_kb_error(code, "missing target button name in line #{n + 3}")
        return
      end
      names = line.split(",")
      names = names.take(slot_max)
      while names.size < slot_max
        names << ""
      end
      slot_max.times do |n|
        b = group[n]
        b.index = n
        b.name = names[n]
      end
    end
    @all_bindings[code.to_sym] = bind
  end

  def self.parsing_kb_error(code, reason)
    puts "Failed to parse #{code}.ini, reason: #{reason}."
  end

  def self.load_all_bindings(files)
    files.each do |fn|
      code = File.basename(fn, "." + Game.data_ext)
      load_bindings(code)
    end
  end

  def self.save_bindings(code)
    file = Game.bindings_path(code)
    binds = @all_bindings[code.to_sym]
    binds.update_active
    save_data(file, binds)
  end

  def self.load_bindings(code)
    file = Game.bindings_path(code)
    @all_bindings[code.to_sym] = load_data(file)
  end

  def self.save_data(fn, obj)
    File.open(fn, "wb") {|f| Marshal.dump(obj, f) }
  end

  def self.load_data(fn)
    obj = nil
    File.open(fn, "rb") {|f| obj = Marshal.load(f) }
    obj
  end
end


module Game
  SCENE_SCRIPT = "Data/Splash"
  SCENE_SCRIPT_EXT = ".rhc"
  DATA = {}
  DATA.default = ""
  RTP = []
  SOUNDFONT_REGEX = "/*.sf{2,3}"
  DATA_EXT = ["", "rxdata", "rvdata", "rvdata2", ""]
  extend self
  attr_reader :shot_formats, :shot_format, :shot_dir, :shot_filename
  attr_reader :shot_path, :save_dir, :save_path, :show_splash
  attr_reader :soundfont, :soundfonts, :env_dir, :user_dir, :user_path
  attr_reader :bind_dir, :bind_path
  attr_accessor :save_filename, :setup_screen
  def self.clear
    @shot_formats = ["jpg", "png"]
    @shot_format = "jpg"
    @shot_dir = "Screenshots"
    @shot_filename = "screenshot"
    @save_dir = "Saves"
    @save_filename = "Save"
    @bind_dir = "KeyBindings"
    @env_dir = ""
    @user_dir = ""
    @soundfont = ""
    @show_splash = false
  end

  def self.make_path(*args)
    args.join("/")
  end

  def self.data_ext
    DATA_EXT[RGSS_VERSION]
  end

  def self.glob_init_kb
    "Input/*." + data_ext
  end

  def self.glob_kb
    @bind_path + "/*." + data_ext
  end

  def self.bindings_path(code)
    @bind_path + "/#{code}." + data_ext
  end

  def self.save_dir=(dir)
    @save_path = make_path(@user_path, dir)
    @save_dir = dir
  end

  def self.init_size
    [WIDTH, HEIGHT]
  end

  def self.normal_size?
    (WIDTH >= 320 && HEIGHT >= 240)
  end

  def self.change_size?
    (WIDTH != START_WIDTH || HEIGHT != START_HEIGHT)
  end

  def self.process_exe_name(list)
    version = 0
    5.times do |n|
      if File.exist?(EXE_BASE_NAME + "." + list[n])
        version = n
      end
    end
    return version
  end

  def self.find_encrypted_ext(ext)
    File.exist?(EXE_BASE_NAME + "." + ext)? 4 : 0
  end

  def self.set_exe_ini_names
    exe_name = RAW_EXE_NAME.gsub(/\.\//, "")
    const_set("EXE_NAME", exe_name)
    const_set("EXE_BASE_NAME", exe_name.sub(/\.\w*/i, ""))
    const_set("INI_FILENAME", EXE_BASE_NAME + ".ini")
  end
    
  def self.process_main_ini
    begin
      lines = File.readlines(INI_FILENAME)
    rescue => e
      puts e.full_message
      return
    end
    lines.size.times do |n|
      line = lines.shift
      if line[0, 1] == ";"
        next
      end
      key, value = line.split(/[\s]{0,}=[\s]{0,}/i)
      if !key
        next
      end
      value = !value ? "" : value.chomp
      if key[/RTP/i] != nil
        if value.size > 1
          RTP << value
        end
      else
        DATA[key] = value
      end
    end
  end

  def self.add_soundfonts(dir)
    @soundfonts += Dir[dir + SOUNDFONT_REGEX].sort
  end

  def self.set_basic_values
    if System.windows?
      default = DATA["SoundFontWin"].to_s
      sf_dir = DATA["SoundFontPathWin"].to_s
      sf_dir = sf_dir.gsub(/[\\]/, "/")
      user_profile = ENV["USERPROFILE"].gsub(/[\\]/, "/")
      @env_dir = make_path(user_profile, "Documents/My Games")
    elsif System.linux?
      default = DATA["SoundFontLnx"].to_s
      sf_dir = DATA["SoundFontPathLnx"].to_s
      @env_dir = make_path(ENV["HOME"], ".local/share")
    end
    System.const_set("SOUNDFONT_DIR", sf_dir)
    System.const_set("SOUNDFONT", default)
    @soundfonts = []
    @soundfont = default
    add_soundfonts(sf_dir)
    add_soundfonts(Dir.pwd + "/Audio/SF2")
    if @soundfont.empty?
      if @soundfonts.size > 0
        @soundfont = @soundfonts[0]
      end
    else
      @soundfonts.delete(@soundfont)
      @soundfonts.unshift(@soundfont)
    end
    company = DATA["Company"]
    title = DATA["Title"]
    const_set("COMPANY", company)
    const_set("TITLE", title)
    if System.linux?
      company = company.gsub(" ", "")
      title = title.gsub(" ", "")
    end
    if company.empty?
      @user_dir = title
    else
      @user_dir = make_path(company, title)
    end
    DATA["Scripts"].sub!(/[\\]/, "/")
    const_set("SCRIPTS", DATA["Scripts"].to_s)
    const_set("VERSION", DATA["Version"].to_s)
    const_set("AUTHOR", DATA["Author"].to_s)
    icon_name = DATA["Icon"].to_s
    icon_name = Dir[icon_name + "*"][0]
    unless FileInt.exist?(icon_name)
      icon_name = ""
    end
    const_set("ICON", icon_name)
    project_ext = ["rhproj", "rxproj", "rvproj", "rvproj2", "rxvproj"]
    encrypt_ext = ["rhc", "rgssad", "rgss2a", "rgss3a", "rgss4a"]
    makers = ["HiddenChest", "XP", "VX", "VX ACE", "XP ACE"]
    n = process_exe_name(encrypt_ext)
    encrypted = n > 0
    unless encrypted
      n = find_encrypted_ext(DATA["CompressedFileExt"])
      if n == 0
        n = process_exe_name(project_ext)
        if n == 0 and !DATA["ProjectFileExt"]&.empty?
          n = 4
        end
      end
    end
    last_proj = DATA["ProjectFileExt"] ||= project_ext[n]
    last_encr = DATA["CompressedFileExt"] ||= encrypt_ext[n]
    Font.default_shadow = n == 2
    Font.default_outline = n >= 3
    debug = (!encrypted && DATA["Debug"][/true/i] != nil)
    enc_ext = encrypt_ext[n]
    filenames = Dir[EXE_BASE_NAME + "*." + enc_ext]
    const_set("DEBUG", debug)
    const_set("MAKER", makers[n])
    const_set("RGSS_VERSION", n)
    const_set("ENCRYPTED_NAMES", filenames)
    w = DATA["Width"].to_i
    h = DATA["Height"].to_i
    w = (w == 0 ? START_WIDTH : w)
    h = (h == 0 ? START_HEIGHT : h)
    const_set("WIDTH", w)
    const_set("HEIGHT", h)
    state = DATA["Fullscreen"][/true/i] != nil
    const_set("FULLSCREEN", state)
    state = DATA["SubImageFix"][/true/i] != nil
    const_set("SUBIMAGEFIX", state)
    puts "Ruby Version:       #{RUBY_VERSION}"
    puts "RGSS Version:       #{n} (#{MAKER})"
    puts "Game Screen Size:   #{WIDTH}x#{HEIGHT}"
    puts "Enable Debug:       #{DEBUG}"
    puts "Trigger Fullscreen: #{FULLSCREEN}"
    puts "SubImage Fix:       #{SUBIMAGEFIX}"
    Font.solid_fonts = DATA["SolidFonts"].to_s[/true/i] != nil
  end

  def self.create_user_dirs
    company = DATA["Company"].gsub(" ", "")
    company_dir = make_path(@env_dir, company)
    if !company.empty? and !Dir.exist?(company_dir)
      Dir.mkdir(company_dir)
    end
    @user_path = make_path(@env_dir, @user_dir)
    Dir.mkdir(@user_path) unless Dir.exist?(@user_path)
    @save_path = make_path(@user_path, @save_dir)
    Dir.mkdir(@save_path) unless Dir.exist?(@save_path)
    @shot_path = make_path(@user_path, @shot_dir)
    Dir.mkdir(@shot_path) unless Dir.exist?(@shot_path)
    Graphics.screenshot_dir = @shot_path
    @bind_path = make_path(@user_path, @bind_dir)
    Dir.mkdir(@bind_path) unless Dir.exist?(@bind_path)
  rescue => e
    puts e.full_message
  end

  def self.soundfont_index
    @soundfonts.index(@soundfont)
  end

  def self.custom_scene_file
    SCENE_SCRIPT + SCENE_SCRIPT_EXT
  end

  def self.setup_custom_scene
    @show_splash = DATA.delete("ShowSplash").to_s[/true/i] != nil
    if FileInt.exist?(SCENE_SCRIPT + ".rb")
      lines = File.binread(SCENE_SCRIPT + ".rb")
      lines = Zlib::Deflate.deflate(lines)
      save_data(lines, custom_scene_file)
      return true
    end
  end

  def self.setup
    set_exe_ini_names
    process_main_ini
    set_basic_values
    create_user_dirs
    set_internal_values
    if System.linux?
      Graphics.wait(10)
    end
    $scene = nil
  end

class SplashScene
  def main
    Graphics.freeze
    start
    Graphics.transition
    Game.setup
    Graphics.freeze
    terminate
  end

  def start
  end

  def terminate
  end
end

end

begin
  $LOAD_PATH << Dir.pwd
  Game.clear
  Game.setup_custom_scene
  if FileInt.exist?(Game.custom_scene_file)
    lines = load_data(Game.custom_scene_file)
    lines = Zlib::Inflate.inflate(lines)
    eval lines
  end
  if Game.show_splash
    $scene = Game::SplashScene.new
    while $scene
      $scene.main
    end
  else
    Game.setup
    Input.load_init_bindings
  end
  puts "Completed setup successfully."
  Game.window_show_borders = true
  puts "Resize the game window"
  Graphics.resize(Game::WIDTH, Game::HEIGHT)
  Graphics.wait(4)
  Graphics.transition(1)
  Graphics.freeze
  Game.icon = Game::ICON
  Game.title = Game::TITLE
  Graphics.show_window
rescue => e
  puts e.full_message
  Game.setup
  Input.load_init_bindings
  Game.icon = Game::ICON || ""
  Game.title = Game::TITLE || ""
  Graphics.wait(4)
  Graphics.transition(1)
  Graphics.freeze
  Graphics.show_window
end